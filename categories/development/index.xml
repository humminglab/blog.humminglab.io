<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Development - Category - All about IoT</title><link>https://blog.humminglab.io/categories/development/</link><description>Development - Category - All about IoT</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>info@humminglab.io (HummingLab)</managingEditor><webMaster>info@humminglab.io (HummingLab)</webMaster><lastBuildDate>Mon, 21 Aug 2023 16:00:00 +0900</lastBuildDate><atom:link href="https://blog.humminglab.io/categories/development/" rel="self" type="application/rss+xml"/><item><title>Yocto 에서 NPM 기반의 Javascript 패키지 관리</title><link>https://blog.humminglab.io/posts/yocto-npm-js-recipe/</link><pubDate>Mon, 21 Aug 2023 16:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-npm-js-recipe/</guid><description><![CDATA[<p><a href="https://blog.humminglab.io/posts/yocto-golang-recipe/" rel="">Yocto에서 Go 프로젝트 관리</a>에 추가하여 JavaScript 기반의 프로그램을 Yocto의 패키지로 관리하는 방법을 정리해 본다.</p>
<p>관련 사항은 Yocto Wiki 의 NPM 기반 패키지 관리 방법에 간략하게 설명되어 있다.</p>
<ul>
<li><a href="https://wiki.yoctoproject.org/wiki/TipsAndTricks/NPM" target="_blank" rel="noopener noreferrer">TipsAndTricks/NPM - Yocto Project</a></li>
</ul>
<p>Javascript 기반의 프로젝트도 Go 언어와 마찬가지로 패키지 관련한 문제가 있지만 이 부분은 어느정도 툴을 이용하여 해결된 상태이다.</p>
<p>임베디드 환경에서 Javascript NPM 를 사용하는 경우를 크게 보면 다음 두 경우가 있을 수 있다.</p>
<ul>
<li>Node.js 기반의 프로젝트</li>
<li>Webpack/React와 같은 static page 생성</li>
</ul>
<p>Node.js와 같은 프로젝트는 빌드 시 <code>nodejs-native</code> 도 필요하지만 target에서 동작하는 <code>nodejs</code>도 필요하다.
하지만 webpack과 같은 경우에는 <code>nodejs-native</code>만 있어서 configure, compile task에서 이를 이용하여 페이지를 생성하면 되고, 별도로 target에 <code>nodejs</code>를 설치할 필요가 없다.</p>]]></description></item><item><title>Yocto 에서 Go 프로젝트 관리</title><link>https://blog.humminglab.io/posts/yocto-golang-recipe/</link><pubDate>Wed, 16 Aug 2023 12:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-golang-recipe/</guid><description><![CDATA[<p>Yocto recipe를 작성하다 보면 대부분의 프로젝트가 C, C++ 로 작성된 것들이라 이들은 참조할 것들이 많다.
하지만 Go, Rust, NodeJS 로 작성된 프로젝트는 Yocto에 추가하려다 보면 참고할 자료가 많지는 않은 편이다.
이 글에서는 Go 언어로 작성된 프로젝트를 추가하는 방법을 정리한다.</p>
<h2 id="go-module" class="headerLink">
    <a href="#go-module" class="header-mark"></a>Go Module</h2><p>우선 간단하게 Go 의 모듈 정책에 대해서 정리 해본다.</p>
<p>2009년에 Go 가 처음 나왔을때는 모듈관리는 단순했다.
Go 프로젝트에서 참고하는 모듈은 <code>go get</code> 으로 다운로드하면 $GOPATH/src 디렉토리에 해당 모듈이 설치된다.
하나의 예를 들면 다음과 같이 src 디렉토리에 모듈 경로를 포함해서 설치가 된다.</p>]]></description></item><item><title>PlatformIO (2) - STM32Cube Platform 개발</title><link>https://blog.humminglab.io/posts/platformio-2-stm32-cube/</link><pubDate>Sat, 25 Jun 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/platformio-2-stm32-cube/</guid><description><![CDATA[<p>이전 글에 이어 PlatformIO를 이용하여 STM32Cube SDK 로 개발환경을 구성하는 것을 정리해 본다.</p>
<ul>
<li><a href="https://blog.humminglab.io/posts/platformio-1/" rel="">PlatformIO (1) - 개요 및 특징</a></li>
<li><strong>PlatformIO (2) - STM32Cube Platform 개발</strong></li>
<li>PlatformIO (3) - STM32Cube FreeRTOS 적용</li>
<li>PlatformIO (4) - PlatformIO 디버깅</li>
<li>PlatformIO (5) - PlatformIO Unit Test</li>
</ul>
<h2 id="platformio로-stm32-platform-설치하기" class="headerLink">
    <a href="#platformio%eb%a1%9c-stm32-platform-%ec%84%a4%ec%b9%98%ed%95%98%ea%b8%b0" class="header-mark"></a>PlatformIO로 STM32 platform 설치하기</h2><p>VSCode에서 아래와 같이 PlatformIO Home을 연다.</p>
<a class="lightgallery" href="/posts/platformio-2-stm32-cube/pio-01.png" title="" data-thumbnail="/posts/platformio-2-stm32-cube/pio-01.png"><img  loading="lazy" src=https://blog.humminglab.io/posts/platformio-2-stm32-cube/pio-01.png    height="auto" width="600px"></a>
<p>New Project 선택하여 다음과 같이 설정</p>
<ul>
<li>Name은 stm32test 와 같이 적절히 설정</li>
<li>Board는 &ldquo;ST Nucleo F103RB&rdquo; 선택</li>
<li>Framework는 &ldquo;STM32Cube&rdquo; 선택</li>
<li>Finish 로 생성</li>
</ul>
<a class="lightgallery" href="/posts/platformio-2-stm32-cube/pio-02.png" title="" data-thumbnail="/posts/platformio-2-stm32-cube/pio-02.png"><img  loading="lazy" src=https://blog.humminglab.io/posts/platformio-2-stm32-cube/pio-02.png    height="auto" width="400px"></a>
<p>우선 동작이 되는지만 확인키 위하여 다음과 같이 src/main.c 로 main() 함수를 만든다.</p>]]></description></item><item><title>PlatformIO (1) - 개요 및 특징</title><link>https://blog.humminglab.io/posts/platformio-1/</link><pubDate>Fri, 24 Jun 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/platformio-1/</guid><description>&lt;p>Cortex-M series 급을 이용한 임베디드 시스템 개발을 하다 보면, 지속적으로 사용할 수 있는 통합 개발 환경이 마땅치 않다는 문제가 있다.
Windows 나 Linux 라면 한번 익혀 두면 수년은 두고 두고 쓸수 있는 개발 환경들이 있지만 임베디드 개발 환경의 경우 MCU 가 바뀔 때마다 개발환경을 바꾸어야만 하는 경우가 생긴다.
개발 환경의 범위를 최소 셋인 컴파일, 다운로드 만이 아닌 디버깅, unit test 까지로 고려한다면 범위가 더 좁아 질 수 밖에 없다.&lt;/p>
&lt;p>지금까지는 대부분의 프로젝트는 임베디드 Linux 와 마찬가지로 gcc, binutils, gdb, OpenOCD 을 이용하여 개발하였고, 디버깅을 지원하는 통합 개발 환경으로는 emacs를 사용하였다.&lt;/p></description></item><item><title>Systemd의 특징과 Yocto에 적용하기</title><link>https://blog.humminglab.io/posts/yocto-systemd/</link><pubDate>Tue, 07 Jun 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-systemd/</guid><description><![CDATA[<p>Yocto project에서 기본 설정으로 빌드하면 SysV Init를 사용한다.
개발하는 제품이 이더넷 네트워크로 연결되고, 부팅 이후에는 네트워크 환경이 변하지 않는다면 SysV Init를 이용하는 것이 구조도 단순해서 더 좋을 수 있다.</p>
<p>하지만 다음과 같은 사항을 고려하고 있다면 systemd를 적용하는 것을 검토해 볼 수 있다.</p>
<ul>
<li>Daemon 이 죽는 경우를 검출하여 재시작 관리가 필요한 경우</li>
<li>Wi-Fi 와 같이 동적으로 변경될 수 있는 네트워크 관리가 필요한 경우</li>
<li>불규칙하게 네트워크가 끊길 수 있는 조건에서 시간 동기화가 필요한 경우</li>
<li>프로그램에 CPU 또는 메모리 자원을 제한하기 위하여 <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt" target="_blank" rel="noopener noreferrer">cgroups</a>를 사용하려는 경우</li>
<li>효과적인 로그 관리를 위하여 journald를 사용하고 싶은 경우</li>
<li>부팅 직후 초기 프로세스의 실행 시간을 줄여 보려는 경우</li>
</ul>
<p>물론 위의 기능을 사용하기 위해서 systemd만 가능한 것은 아니지만, systemd를 사용하는 경우 별도의 프로그램 없이 위 기능을 쉽게 적용할 수 있다.</p>]]></description></item><item><title>Syslog and Journald</title><link>https://blog.humminglab.io/posts/syslog-journald/</link><pubDate>Fri, 27 May 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/syslog-journald/</guid><description><![CDATA[<p>대부분의 최신 linux 배포본에서 systemd를 적용하면서 로그 시스템도 syslog 에서 systemd 의 journald로 변경되었다.</p>
<p>PC급 이상의 linux 배포본에서는 journald와 기존 호환성을 고려하여 syslog 데몬이 같이 사용하도록 기본 설정되어 있고,
상대적으로 광활한 저장장치과 메모리를 가지고 있고, 적절한 용량 선에서 log rotate가 되도록 설정되어 있어,
사용자가 설치 후 로그에 대해서는 신경을 쓸 필요가 거의 없다.</p>
<p>하지만 용량이 작은 저장장치와 메모리를 가진 embedded linux 제품을 개발하는 경우에는 시스템 로그를 어떤 식으로 관리 할지 충분히 고민하고 설정하여야 한다.
그렇지 않다면 저장장치나 메모리가 로그로 가득차 버려서 더이상 동작을 하지 못하는 문제가 발생할 수 있다.
Flash memory를 저장장치로 사용하는 경우에는 제품 수명 보다 저장장치의 수명이 길 수 있도록 erase 횟수도 감안하여 고려하여야 한다.</p>]]></description></item><item><title>Yocto에 OSTree upgrade 적용(3) - 업그레이드/롤백 및 OSTree 리뷰</title><link>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-3/</link><pubDate>Wed, 16 Feb 2022 22:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-3/</guid><description><![CDATA[<p>이전글 <a href="https://blog.humminglab.io/posts/yocto-ostree-meta-updater-1/" rel="">Yocto에 OSTree upgrade 적용(1)</a> 에서 Yocto를 이용한 빌드 과정과,
<a href="https://blog.humminglab.io/posts/yocto-ostree-meta-updater-2/" rel="">Yocto에 OSTree upgrade 적용(2)</a> 에서 OSTree를 적용한 이미지의 부팅 과정에 대해서 설명하였다.</p>
<p>이번 글에서는 OSTree가 적용된 이미지를 실제로 업그레이드 하는 방법, 롤백 절차, 프로그램에서 이를 관리하는 방법에 대해서 설명한다.</p>
<p>이해를 돕고자 OSTree의 업그레이드 절차를 git과 비교하여 설명한다.
OSTree는 ostree CLI 명령을 이용하여 업그레이드 과정을 수행할 수 있고, libostree library 를 이용하여 프로그램으로 구현할 수 도 있다. 이 글에서는 CLI를 이용하는 업그레이드 방법을 설명한다.</p>]]></description></item><item><title>Yocto에 OSTree upgrade 적용(2) - 부팅 절차</title><link>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-2/</link><pubDate>Mon, 14 Feb 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-2/</guid><description><![CDATA[<p>이전글 <a href="https://blog.humminglab.io/posts/yocto-ostree-meta-updater-1/" rel="">Yocto에 OSTree upgrade 적용(1) - 이미지 생성</a> 에서는 Yocto 빌드 과정을 통한 target 에 write 할 이미지를 만드는 과정까지 설명 하였다.</p>
<p>이번글에서는 부팅 이미지를 이용하여 부팅 절차를 설명한다.</p>
<h2 id="디스크-이미지-파일" class="headerLink">
    <a href="#%eb%94%94%ec%8a%a4%ed%81%ac-%ec%9d%b4%eb%af%b8%ec%a7%80-%ed%8c%8c%ec%9d%bc" class="header-mark"></a>디스크 이미지 파일</h2><p>최종적으로 디스크에 쓰는 이미지를 Yocto 의 wic 툴을 이용하여 확인해 보면 다음과 같이 두개의 partition 으로 구성된다.</p>
<ul>
<li>Partiton 1(fat16): DOS FAT16 의 부팅 디스크로 u-boot 과 부팅에 필요한 설정 파일이 있다.
<ul>
<li>파일 중 boot.scr 파일이 있는데, 이 파일로 u-boot 의 script를 대체하여 OSTree 이미지가 로드되도록 한다.</li>
</ul>
</li>
<li>Partition 2(ext4): OSTree용 이미지</li>
</ul>
<div class="code-block highlight is-open show-line-numbers  tw-group tw-my-2">
  <div class="
    code-block-title 
    
    tw-flex 
    tw-flex-row 
    tw-justify-between 
    tw-w-full tw-bg-bgColor-secondary
    ">      
    <button 
      class="
        tw-select-none 
        tw-mx-2 
        tw-block
        group-[.is-open]:tw-rotate-90
        tw-transition-[transform] 
        tw-duration-500 
        tw-ease-in-out
        print:!tw-hidden"
      disabled
      aria-hidden="true"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"/></svg></button>

    <div class="code-block-title-bar tw-w-full">
      <p class="tw-select-none !tw-my-1">shell</p>]]></description></item><item><title>Yocto에 OSTree upgrade 적용(1) - 이미지 생성</title><link>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-1/</link><pubDate>Wed, 26 Jan 2022 21:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-1/</guid><description><![CDATA[<p>Linux PC 의 경우 각 배포본 마다 yum, rpm, dpkg 등의 package manager를 제공하여, 이를 이용하여 패키지를 최신 버전으로 유지 관리할 수 있다.
임베디드의 경우도 <a href="https://www.raspberrypi.com/software/" target="_blank" rel="noopener noreferrer">Raspberry Pi OS</a>, <a href="https://www.armbian.com/" target="_blank" rel="noopener noreferrer">armbian</a> 은 PC 에서 사용하는 package manager 방식을 제공하고, Yocto 도 rpm 등을 이용하여 패키지 관리가 가능하다.</p>
<p>이들 패키지 매니저는 패키지 데이타베이스를 업데이트 하고, 패키지 업그레이드 시 의존성 있는 추가 패키지도 다운로드 받아서 설치/삭제하고, 설치 전/후처리를 위한 script를 자동으로 실행시켜서 최종 상태를 만들어 준다. 하지만 임베디드 제품의 경우 이같은 방식은 다음과 같은 유지 관리 문제를 가져 올 수 있다.</p>]]></description></item><item><title>Port Mirroring 기능 지원 저렴한 스위치 - GS108Ev3</title><link>https://blog.humminglab.io/posts/port-mirroring-network-switch-gs108ev3/</link><pubDate>Wed, 19 Jan 2022 10:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/port-mirroring-network-switch-gs108ev3/</guid><description><![CDATA[<p>네트워크 프로토콜을 개발 하다보면 Wireshark 등으로 패킷을 캡쳐하여 분석할 일이 종종 생긴다.
Linux 장치라면 tcpdump나 wireshark을 실행해서 직접 패킷 캡쳐가 가능하지만, 그렇지 않은 경우에는 Network TAP 이나 이더넷 스위치의 port mirroring 기능을 사용하여서 패킷을 캡쳐하여야 한다.
Amazon 등에서 검색해보면 Network Tap 도 $200~300 정도로 비싼 편이고, 포트 미러링와 유사한 기능도 고급 스위치에서만 지원된다.</p>
<p>찾다 보니 Netgear <a href="https://www.netgear.com/business/wired/switches/plus/gs108e/" target="_blank" rel="noopener noreferrer">GS108Ev3</a>(8포트), <a href="https://www.netgear.com/business/wired/switches/plus/gs105ev2/" target="_blank" rel="noopener noreferrer">GS105Ev2</a>(5포트) 가 가격도 5~8만원 정도로 비싸지 않고, 포트 미러링 기능이 지원되어 소개한다.</p>
<p>외관은 금속으로 되어 있어 크기에 비하여 무게가 묵직하게 나간다.</p>]]></description></item></channel></rss>