<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Security - Category - All about IoT</title><link>https://blog.humminglab.io/categories/security/</link><description>Security - Category - All about IoT</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>info@humminglab.io (HummingLab)</managingEditor><webMaster>info@humminglab.io (HummingLab)</webMaster><lastBuildDate>Sun, 23 Jul 2023 09:00:00 +0900</lastBuildDate><atom:link href="https://blog.humminglab.io/categories/security/" rel="self" type="application/rss+xml"/><item><title>HTTP SHA-256 Digest Authentication</title><link>https://blog.humminglab.io/posts/http-sha-256-digest-auth/</link><pubDate>Sun, 23 Jul 2023 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/http-sha-256-digest-auth/</guid><description><![CDATA[<p>일반 웹 환경에서는 이제는 사양화 되어 거의 사용하지는 않지만,
CCTV 표준인 <a href="https://www.onvif.org" target="_blank" rel="noopener noreferrer">ONVIF</a>나 관련 보안 인증에서는 아직까지 HTTP Digest Authentication 을 사용한다.</p>
<p>이 글에서는 HTTP Digest Authentication의 전반적인 사항을 정리한다.
목차는 다음과 같다.</p>
<ul>
<li>HTTP MD5, SHA-2 (SHA-256) Digest 인증 절차</li>
<li>Digest Authentication</li>
<li>웹 환경에서 더이상 사용하지 않는 이유</li>
<li>브라우저에서 SHA-256 Digest Authentication 구현 방법</li>
</ul>
<h2 id="http-md5-sha-2-sha-256-digest-인증-절차" class="headerLink">
    <a href="#http-md5-sha-2-sha-256-digest-%ec%9d%b8%ec%a6%9d-%ec%a0%88%ec%b0%a8" class="header-mark"></a>HTTP MD5, SHA-2 (SHA-256) Digest 인증 절차</h2><p>HTTP Authentication은 RFC 표준으로 다음과 같이 정의 되어 있다.</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc2617" target="_blank" rel="noopener noreferrer">RFC 2617 - HTTP Authentication: Basic and Digest Access Authentication</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7616" target="_blank" rel="noopener noreferrer">RFC 7616 - HTTP Digest Access Authentication</a></li>
</ul>
<p>웹 초창기에 사용자 인증이 필요한 페이지를 위하여  RFC 2617 로 표준이 정의 되었다.
이 표준안에는 다음과 같은 2가지 인증을 정의한다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(14) - PKI and X.509</title><link>https://blog.humminglab.io/posts/tls-cryptography-14-x509/</link><pubDate>Sun, 02 Apr 2023 20:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-14-x509/</guid><description><![CDATA[<p>이전글 에서 설명한 <a href="https://blog.humminglab.io/posts/tls-cryptography-9-dsa/" rel="">Digital Signature</a> 를 사용하면 문서의 서명을 검증할 수 있다. 이 서명을 체이닝으로 이어 나가면 3자 인증 기반의 PKI(Public Key Infrastructure)를 구성할 수 있다. <a href="https://www.itu.int/rec/T-REC-X.509" target="_blank" rel="noopener noreferrer">X.509</a> 는 ITU-T 에서 정의한 PKI 표준이다. 우리가 흔히 사용하는 인증서는 X.509 표준을 따른다.</p>
<p>인증의 기본적인 방법은 다음과 같은 절차이다.</p>
<ul>
<li>Root 인증 기관(Certificate Authority, CA)가 있다고 하자. Root CA는 자신의 public key 를 별도의 방법으로 공개를 한다. 일반적인 PC 환경에서는 웹브라우저나 OS에 검증된 CA 인증서들이 내장되어 있다.</li>
<li>Alice는 자신의 정보와 public key를 포함한 문서를 만들어서 Root CA에게 별도의 방법으로 제출(CSR, Certificate Signing Request)하여 root CA의 private key로 서명을 받아온다.</li>
<li>다른 사용자 Bob은 Alice와 통신 시 먼저 인증서를 요청하면 Alice는 자신의 인증서를 보낸다.</li>
<li>Bob은 Alice의 인증서를 Root CA의 public key로 서명 검증한다.</li>
<li>Bob이 Alias에게 임의의 랜덤한 문자열을 보내어 서명을 요청하면 Alias는 자신의 private key로 서명을 하여 Bob에게 보낸다.</li>
<li>Bob은 Alias의 public key로 서명을 검증해 보면 Alias private key를 들고 있는 Alias 본인임을 알 수 있다.</li>
</ul>
<pre class="mermaid">sequenceDiagram
    participant Root CA
    participant Alias
    participant Bob
    Root CA-->>Bob: Root CA public key 전달
    Alias-->>Root CA: 자신의 정보와 public key를 포함한 문서 전달
    Root CA-->>Alias: Root CA private key로 서명하여 전달
    Bob->>Alias: Alias 인증서 요청
    Alias->>Bob: Alias 인증서 전달
    note over Bob: Alias 인증서를 root CA publickey로 검증
    Bob->>Alias: 임의의 랜덤한 문자열 전달
    Alias->>Bob: 문자열을 Alias private key로 서명하여 전달
    note over Bob: Alias public key로 서명 검증
</pre><p>위와 같은 절차가 PKI를 이용하여 서버 검증을 하는 기본적인 방법이다. 사전에 Root CA 인증서만 있으면, 이 Root CA 가 서명한 인증서를 검증할 수 있다. 이와 깉은 인증 체인을 2단계, 3단계 이상으로 체인으로 연결하여 구성할 수도 있다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(13) - MAC, AE, AEAD</title><link>https://blog.humminglab.io/posts/tls-cryptography-13-mac-aead/</link><pubDate>Sat, 30 Apr 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-13-mac-aead/</guid><description><![CDATA[<p>지금까지 설명한 암호화 알고리즘을 조합하여 확장을 해보기로 한다.</p>
<p>이 글에서 설명할 내용은 다음과 같다.</p>
<ul>
<li>MAC(Message Authentication Code)</li>
<li>AE(Authenticated Encryption)</li>
<li>AEAD(Authenticated Encryption with Associated Data)</li>
</ul>
<h2 id="mac-message-authentication-code" class="headerLink">
    <a href="#mac-message-authentication-code" class="header-mark"></a>MAC (Message Authentication Code)</h2><p>MAC은 한마디로 정리하면 <a href="https://blog.humminglab.io/posts/tls-cryptography-10-hash/" rel="">Hash</a>에 비밀키를 추가한 버전이라고 볼 수 있다.</p>
<p>키를 사용한다는 것으로 보면 <a href="https://blog.humminglab.io/posts/tls-cryptography-9-dsa/" rel="">DSA</a> 디지털 서명과 비슷한 기능을 수행하지만, 공유키를 사용한다는 것이 다르다.</p>
<p>DSA는 Alice의 공개키를 가진 다수의 사람이 검증을 위한 용도이고, MAC은 키를 공유한 사람 간에 검증을 하기 위한 용도이다. 물론 연산량도 DSA와 비교하여 더 적고 빠르다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(12) - ECDH, ECDSA</title><link>https://blog.humminglab.io/posts/tls-cryptography-12-ecc2/</link><pubDate>Tue, 19 Apr 2022 13:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-12-ecc2/</guid><description><![CDATA[<p>이전 글 <a href="https://blog.humminglab.io/posts/tls-cryptography-11-ecc/" rel="">Elliptic Curve Cryptography(ECC)</a>에서는 타원곡선 암호의 특징 및 알고리즘을 알아보았다.</p>
<p>이번에는 이를 활용한 암호화 응용과 실제 사용 예를 살펴보기로 한다.</p>
<h2 id="ecc-vs-rsa" class="headerLink">
    <a href="#ecc-vs-rsa" class="header-mark"></a>ECC vs. RSA</h2><p>공개키 암호화 방법으로 <a href="https://blog.humminglab.io/posts/tls-cryptography-8-rsa/" rel="">RSA</a>와 비교하여 이야기 되나, 실제적으로 ECC는 RSA와 동일한 기능으로 사용하지는 않는다.</p>
<p>정확히는 RSA가 아니라 이산대수 문제를 이용한 <a href="https://blog.humminglab.io/posts/tls-cryptography-7-diffie-hellman/" rel="">DH</a> 나
<a href="https://blog.humminglab.io/posts/tls-cryptography-9-dsa/" rel="">DSA</a> 용도로 사용한다고 말할 수 있다.</p>
<p>RSA의 경우 아래와 같이 평문 $k$ 를 공개키 $e$로 모듈러 지수 연산을 하는 형식이다.</p>
<p>$$ E = k^e \pmod{n} $$</p>
<p>ECC의 경우 평문이 아닌 순환되는 subgroup 이 좋은 generator $G$를 선정하여 이를 키 $e$ 로 곱하는 것이다.
$$ E = eG \pmod{p} $$</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(11) - Elliptic Curve Cryptography(ECC)</title><link>https://blog.humminglab.io/posts/tls-cryptography-11-ecc/</link><pubDate>Mon, 18 Apr 2022 10:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-11-ecc/</guid><description><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Elliptic_curve" target="_blank" rel="noopener noreferrer">타원 곡선(Elliptic Curve)</a>는 일반적으로 생각하는 가로 세로비가 다른 길쭉한 원을 말하는 것이 아니라 다음과 같은 공식으로 구성된 곡선을 말한다.</p>
<p>$$y^2 = x^3 + ax + b$$</p>
<p>$a$ 와 $b$ 는 임의의 수로 특이점이 없도록 다음과 같은 조건을 만족하여야 한다.</p>
<p>$$4 a^3 + 27b^2 \neq 0$$</p>
<p>이와 같은 조건을 만족하는 곡선은 다음과 같은 모양을 가진다.</p>
<figure><img src="/posts/tls-cryptography-11-ecc/curves.png"
    alt="b=1, a=2~-3 일 때의 모양" width="400px" height="auto"><figcaption>
      <p>b=1, a=2~-3 일 때의 모양</p>
    </figcaption>
</figure>

<p>만일 위 조건을 만족하지 않는 경우는 아래와 같이 첨 점이거나 교차하는 특이점이 있다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(10) - Hash</title><link>https://blog.humminglab.io/posts/tls-cryptography-10-hash/</link><pubDate>Sat, 16 Apr 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-10-hash/</guid><description><![CDATA[<p>Hash 함수란 임의의 길이의 데이타를 축약하여 고정된 길이의 데이타로 매핑하는 함수를 말한다.</p>
<p>데이타 검색을 위한 hash 함수, 데이타 손상을 검출하기 위한 CRC32 도 hash 함수 이지만, 이 글에서 언급하는 것은 암호화 해시 함수이다.</p>
<p>각 용도에 따라서 해시 함수의 특성은 다음처럼 다를 수 있다.</p>
<ul>
<li>데이터 검색용: 모든 입력 데이타에 대해서 hash 결과값이 균등 분포를 가져야 한다.</li>
<li>데이타 손상 검출용: 원하는 비트 개수 까지의 오류에 대해서 정확히 검출되어야 하고, 알고리즘에 따라서 제한된 비트 개수 까지 오류 복원이 가능하여야 한다.</li>
<li>암호화용: 해시 값으로 원본을 추측 불가능하여야 하고, 임의의 두 데이타가 동일한 해시값을 가지는 충돌이 실제적으로 불가능하여야 한다.</li>
</ul>
<h2 id="암호화-hash의-특징" class="headerLink">
    <a href="#%ec%95%94%ed%98%b8%ed%99%94-hash%ec%9d%98-%ed%8a%b9%ec%a7%95" class="header-mark"></a>암호화 hash의 특징</h2><p>우선 용어를 정리해 보자.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature</title><link>https://blog.humminglab.io/posts/tls-cryptography-9-dsa/</link><pubDate>Tue, 12 Apr 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-9-dsa/</guid><description><![CDATA[<p>DSA는 Digital Signature Algorothm 의 약자로, 미국 NIST 에서 제정한 디지털 서명 알고리즘이다.</p>
<p>이번 글에서는 이와 같은 디지털 서명에 관한 전반적인 사항을 다음과 같은 순서로 정리한다.</p>
<ul>
<li>RSA 서명 알고리즘</li>
<li>ElGamal 서명 알고리즘</li>
<li>DSA 서명 알고리즘</li>
<li>OpenSSL 을 이용한 동작 확인</li>
</ul>
<h2 id="rsa-signature" class="headerLink">
    <a href="#rsa-signature" class="header-mark"></a>RSA Signature</h2><p>RSA 서명 방식은 앞의 <a href="https://blog.humminglab.io/posts/tls-cryptography-8-rsa/" rel="">RSA</a> 글에서 언급한 것과 같이
개인키로 문서의 Hash 값을 암호화 하는 것으로 RSA의 동작 원리를 알고 있으면 직관적이다.
관련 표준은 <a href="https://tools.ietf.org/html/rfc8017" target="_blank" rel="noopener noreferrer">PKCS#1</a>의 8장 을 보면 된다.</p>
<p>서명 절차는 아래와 같다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(8) - RSA</title><link>https://blog.humminglab.io/posts/tls-cryptography-8-rsa/</link><pubDate>Mon, 21 Mar 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-8-rsa/</guid><description><![CDATA[<p>지난 번에 설명한 <a href="https://blog.humminglab.io/posts/tls-cryptography-6-math/" rel="">이산대수</a>를 이용하면 RSA 의 기본원리도 쉽게 이해할 수 있다.</p>
<p>RSA는 이름에 특별한 의미는 없고, 알고리즘을 발명한 사람들(Ron Rivest, Adi Shamir, Leonard Adleman)의 약자를 따서 만든 것이다.</p>
<p><a href="https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/" rel="">AES</a>와는 달리 공개키(public key)와 개인키(private key) 두 벌로 구성된 키를 가지고 있는 비대칭키 암호화 알고리즘이다.</p>
<p>가장 일반적인 사용용도는 다음과 같이 Bob 이 Alice에게 암호 데이타 전달하는 방법이다.</p>
<ul>
<li>Alice의 공개키는 공개되어 누구나 알수 있다.</li>
<li>Bob은 Alice의 공개키를 이용하여 암호화 하여 일반 채널로 전달한다.</li>
<li>Alice는 자신의 개인키로 복호화 하여 Bob이 보낸 데이타를 얻을 수 있다.</li>
</ul>
<pre class="mermaid">sequenceDiagram
Participant Alice
Participant Bob
Alice ->> Bob: 공개키(K_pub) 배포
note over Bob: P=본문<br/>E=RSA(K_pub, P)
Bob ->> Alice: 암호화된 데이타(E) 전송
note over Alice: P=RSA(K_pri, E)

</pre>
<p>이 과정에서 암호화된 데이타를 다른 사람이 도청을 하더라도, Alice 의 private key가 없는 이상 복호화 할 방법은 없다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(7) - Diffie-Hellman Key Exchange</title><link>https://blog.humminglab.io/posts/tls-cryptography-7-diffie-hellman/</link><pubDate>Thu, 10 Mar 2022 16:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-7-diffie-hellman/</guid><description><![CDATA[<p>지난 번에 설명한 <a href="https://blog.humminglab.io/posts/tls-cryptography-6-math/" rel="">이산대수</a>를 이용하여 Diffie-Hellman Key Exchange(DHKE, 키교환 또는 키합의)을 이해해 보자.</p>
<p>TLS 암호화 채널을 절차를 간단하게 보면 다음과 같다.</p>
<ul>
<li>서버를 믿을 수 있는지 검증, 필요시 클라이언트도 인증</li>
<li>RSA 암호화 채널로 키를 전달하거나, Diffie-Hellman 방식으로 키교환</li>
<li>교환한 키로 AES, ChaCha20와 같은 대칭키로 암호화</li>
</ul>
<p>Diffie-Hellman은 여기서 두번째 대칭키를 교환하는 방법이다.</p>
<p>RSA와 같은 비대칭키를 이용하여 암호화 채널을 만든 후 이를 이용하여 대칭키를 전달하는 것은 직관적이다.
하지만 Diffie-Hellman 방식은 이와 같은 암호화 채널 없이도, 서로 키를 교환할 수 있는 방식이다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(6) - 이산 대수</title><link>https://blog.humminglab.io/posts/tls-cryptography-6-math/</link><pubDate>Thu, 03 Mar 2022 00:20:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-6-math/</guid><description><![CDATA[<p>키 합의, 비대칭키는 역연산이 실제적으로 불가능한 수학적 이론을 기반으로 만들어진 알고리즘이기 때문에, 이의 기본 동작을 이해하기 위해서는 수학적인 지식이 어느정도 필요하다.</p>
<p>여기에서는 이들 알고리즘의 동작 원리에 필요한 최소한의 수학을 정리해본다.</p>
<p>타원알고리즘을 제외하고, 키합의와 비대칭키 알고리즘을 이해하기 위해서는 다음과 같은 것을 알아야 한다.</p>
<ul>
<li>소인수 분해</li>
<li>유클리드 호제법을 이용하여 두 수의 최대 공약 수 찾기</li>
<li>확장 유클리드 호제법으로 소수 모듈로 연산에서 곱하기 역원 찾기</li>
<li>페르마 소정리를 이용하여 소수 모듈로의 지수 연산 역원 찾기</li>
<li>오일러 정리를 이용하여 일반 모듈로에서 지수 역원 찾기</li>
</ul>
<h2 id="소인수-분해" class="headerLink">
    <a href="#%ec%86%8c%ec%9d%b8%ec%88%98-%eb%b6%84%ed%95%b4" class="header-mark"></a>소인수 분해</h2><p>임의의 정수를 소인수 분해하는 데에는 효과적인 방법이 없다. 기본적으로 2부터 정수의 1/2에 해당하는 수까지 하나씩 나누어 보면서 나머지가 있는지를 확인해 보는 수 밖에 없다.</p>]]></description></item></channel></rss>