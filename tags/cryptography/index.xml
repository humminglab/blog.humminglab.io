<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Cryptography - Tag - All about IoT</title><link>https://blog.humminglab.io/tags/cryptography/</link><description>Cryptography - Tag - All about IoT</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>info@humminglab.io (HummingLab)</managingEditor><webMaster>info@humminglab.io (HummingLab)</webMaster><lastBuildDate>Wed, 02 Mar 2022 18:00:00 +0900</lastBuildDate><atom:link href="https://blog.humminglab.io/tags/cryptography/" rel="self" type="application/rss+xml"/><item><title>TLS/암호 알고리즘 쉽게 이해하기(5) - Stream Cipher</title><link>https://blog.humminglab.io/posts/tls-cryptography-5-stream-cipher/</link><pubDate>Wed, 02 Mar 2022 18:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-5-stream-cipher/</guid><description><![CDATA[<p>일정 데이터 단위로 암호화를 하는 <a href="https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/" rel="">블럭 암호</a>와 비교하여 스트림 암호(Stream Cipher)는 비트 또는 바이트 단위로 암호화를 하는 방식이다.</p>
<p>쉽게 말해서 블럭 암호는 키를 사용하여 (필요하면 IV도 포함해서) 블럭단위로 전치와 치환을 통하여 암호하를 가하는 방식이라고 할 수 있다. 이와 비교하여 스트림 암호는 키와 IV(Initial Vector)로 다양한 연산을 이용하여 난수열을 만들고, 이를 이용하여 평문과 XOR 과정을 통하여 암호화를 하는 것이다. 블럭 암호에서 설명한 <a href="https://blog.humminglab.io/posts/tls-cryptography-4-block-cipher-mode/#aes-ctr-counter" rel="">AES-CTR</a>와 같은 것이 이와 같은 난수열을 만드는 방법 중 하나이다.</p>
<p>가장 이상적인 스트림 암호는 <a href="https://blog.humminglab.io/posts/tls-cryptography-2-random/" rel="">True Random Number Generator(TRNG)</a>를 사용하여 만들어낸 난수열이다. 예를 들어 1MB의 난수열을 만들고, 이를 임의의 방식으로 상대방과 사전에 공유를 하였다고 하자. 이를 이용하면 1MB 까지의 평문을 XOR 하여 전달을 할 수 있고, 난수열을 가지고 있지 않은 어떠한 사람도 데이타 원본을 알 방법이 없다. 문제는 이와 같은 커다란 난수열을 교환하는 것이 쉽지 않다는 것이다. 아래에 설명하지만 그렇다고 한번 사용한 난수열을 다시 재 사용하여 다른 데이타를 암호화 할 수는 없다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(3) - Block Cipher</title><link>https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/</link><pubDate>Mon, 21 Feb 2022 20:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/</guid><description><![CDATA[<p>암호 알고리즘은 암호화/복호화 작업을 동일한 키 하나로 사용하는지, 아니면 암호화하는 키(공개키)와 복호화 하는 키(개인키)를 따로 사용하는지에 따라 각각 대칭키(Symmetric Key), 비대칭키(Asymmetric Key) 방식으로 나뉜다.</p>
<pre class="mermaid">
graph TD;

subgraph Symmetric Key
A1([평문]) --> B1[암호화 모듈] --> C1([암호문])
K1([키]) --> B1

C2([암호문]) --> B2[복호화 모듈] --> A2([평문])
K1 --> B2
end

subgraph Asymmetric Key
A3([평문]) --> B3[암호화 모듈] --> C3([암호문])
K2([공개키]) --> B3

C4([암호문]) --> B4[복호화 모듈] --> A4([평문])
K3([개인키]) --> B4
end

style B1 fill:#FFF9C4
style B2 fill:#FFF9C4
style B3 fill:#FFF9C4
style B4 fill:#FFF9C4

</pre>
<p>대칭키는 암호화 할때 일정 블럭 크기(예를 들어 128bits)를 한번에 암호화 할지, 아니면 비트/바이트 단위로 암호화 하는지에 따라서 블럭 암호(Block Cipher), 스트림 암호(Stream Cipher) 로 구분한다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(2) - Random</title><link>https://blog.humminglab.io/posts/tls-cryptography-2-random/</link><pubDate>Fri, 11 Feb 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-2-random/</guid><description><![CDATA[<p>암호 알고리즘에서 난수는 중요한 요소이다.
예를 들어 암호 키 생성 시에도 난수로 만드는데, 생성된 난수가 편향성을 가지게 되면 암호 알고리즘이 아무리 좋아도 취약해 질 수 밖에 없다.</p>
<p>한 예로 오래전 일이지만, 2008년 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0166" target="_blank" rel="noopener noreferrer">Debian linux OpenSSL 0.9.8 의 잘못된 patch</a>로 seed를 current process ID 로만 사용하여 결과적으로 65,536개의 값 중 하나로 난수가 생성되어 brute force 공격으로 키를 찾을 수 있는 문제가 발생한 적도 있고, 이외에도 <a href="https://cwe.mitre.org/find/index.html" target="_blank" rel="noopener noreferrer">CWE(Commn Weakness Enumeration)</a> 에서 random 으로 검색해보면 문제가 되었던 여러 케이스들을 찾아 볼 수 있다.</p>]]></description></item><item><title>TLS/암호 알고리즘 쉽게 이해하기(1) - 개요</title><link>https://blog.humminglab.io/posts/tls-cryptography-1-overview/</link><pubDate>Wed, 09 Feb 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/tls-cryptography-1-overview/</guid><description>&lt;p>HTTPS의 SSL/TLS를 이해하는 것은 생각만큼 쉽지 않다. React, kubernetes 같이 오픈 생태계에서 핫 한 분야들은 다양한 시각으로 설명한 자료들이 많아 여러 방법으로 이해할 수도 있겠지만, 수십여년간 수학자, 암호학자들에게서 다듬어진 암호학에 대해서는 말랑말랑한 자료를 찾기가 쉽지는 않다. 좋은 자료라고 찾아 보아도 읽다 보면 이내 수많은 용어들과 수학 이론에 막혀 버리곤 한다.
그렇다고 제대로된 이해없이 SSL/TLS 나 암호화 알고리즘을 사용하게 되면 작은 실수로 인하여 보안에 심각한 문제를 만들 수도 있다.&lt;/p>
&lt;p>여기에서는 일반 개발자를 위한 관점으로 암호 알고리즘과 TLS/SSL을 정리해 보기로 한다.
암호 알고리즘을 사용하는 입장이라면 이의 수학적인 지식에 대하여 모두 이해할 필요는 없다.
다만, 알고리즘이 어떤 원리로 구성 되는지를 이해하고, 이의 사용 방법과 사용해서는 안되는 취약 패턴을 안다면 충분하다.
동작 원리를 이해하는데 필요한 부분은 중학교 수학 수준에서 설명하고, 전체를 조합하여 TLS를 이해하는 것을 목표로 한다.&lt;/p></description></item></channel></rss>