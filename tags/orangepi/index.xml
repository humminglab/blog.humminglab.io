<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>OrangePi - Tag - All about IoT</title><link>https://blog.humminglab.io/tags/orangepi/</link><description>OrangePi - Tag - All about IoT</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>info@humminglab.io (HummingLab)</managingEditor><webMaster>info@humminglab.io (HummingLab)</webMaster><lastBuildDate>Tue, 18 Jan 2022 23:00:00 +0900</lastBuildDate><atom:link href="https://blog.humminglab.io/tags/orangepi/" rel="self" type="application/rss+xml"/><item><title>Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/</link><pubDate>Tue, 18 Jan 2022 23:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/</guid><description><![CDATA[<p>Yocto Project 개발 절차는 기본적으로 이미 개발이 완료된 패키지들의 recipe를 만들고, 이를 bitbake로 전체 이미지를 빌드하는 과정이다.</p>
<p>하지만 개발 진행 중인 소프트웨어 패키지를 yocto에 추가하고, 이를 계속 수정 개발을 할 때 어떤 방식으로 관리를 할지 고민을 하여야 한다.
여기에서는 이와 같이 개발 중인 패키지를 yocto 에 추가하여 빌드 하는 방법을 알아본다.</p>
<ul>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/" rel="">Yocto Project 개발하기(1) - Orange Pi 보드 빌드</a></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/" rel="">Yocto Project 개발하기(2) - Custom Layer 만들기</a></li>
<li><strong>Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</strong></li>
<li>Yocto Project 개발하기(4) - Yocto SDK 빌드</li>
<li>Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델</li>
</ul>
<h2 id="방법들" class="headerLink">
    <a href="#%eb%b0%a9%eb%b2%95%eb%93%a4" class="header-mark"></a>방법들</h2><p>예를 들어 u-boot 를 수정 하는 경우를 예로 들어 보자.
수정되어 commit 된 경우라면 bb(append) recipe만 수정해서 재실행하면 되지만, commit 전에 yocto 에 추가하여 빌드하려면 다음과 같은 방법을 고려해 볼 수 있다.</p>]]></description></item><item><title>Yocto Project 개발하기(2) - Custom Layer 만들기</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</link><pubDate>Fri, 07 Jan 2022 19:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</guid><description><![CDATA[<p><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/" rel="">이전 글</a> 에서 meta-sunxi 를 추가하여 orage pi 용으로 빌드를 만들었고, 이번 과정은 project 용으로 meta layer를 만들어서 관리하는 방법을 설명한다.</p>
<p>실제 개발 과정을 이해하기 좋도록 meta layer 를 만들어 가는 과정을 설명한다.</p>
<ul>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/" rel="">Yocto Project 개발하기(1) - Orange Pi 보드 빌드</a></li>
<li><strong>Yocto Project 개발하기(2) - Custom Layer 만들기</strong></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/" rel="">Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</a></li>
<li>Yocto Project 개발하기(4) - Yocto SDK 빌드</li>
<li>Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델</li>
</ul>
<h2 id="layer-및-machine-생성" class="headerLink">
    <a href="#layer-%eb%b0%8f-machine-%ec%83%9d%ec%84%b1" class="header-mark"></a>Layer 및 machine 생성</h2><p>프로젝트를 sc-gateway 라고 명하고(이름에 특별한 의미는 없음), 이를 layer로 만든다. 다음과 같이 yocto 폴더 안에 meta-sc-gateway를 생성한다.</p>]]></description></item><item><title>Yocto Project 개발하기(1) - Orange Pi 보드 빌드</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/</link><pubDate>Thu, 30 Dec 2021 22:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/</guid><description><![CDATA[<p>이 문서는 <a href="http://www.orangepi.org/orangepizero/" target="_blank" rel="noopener noreferrer">Orange Pi Zero</a> 보드에서 <a href="https://www.yoctoproject.org/" target="_blank" rel="noopener noreferrer">Yocto Project</a>를 이용하여 배포본을 만들고, 개별 패키지를 관리하는 방법에 대하여 설명한다.</p>
<p>설명은 다음과 같이 나누어서 설명을 할 예정이다.</p>
<ul>
<li><strong>Yocto Project 개발하기(1) - Orange Pi 보드 빌드</strong></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/" rel="">Yocto Project 개발하기(2) - Custom Layer 만들기</a></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/" rel="">Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</a></li>
<li>Yocto Project 개발하기(4) - Yocto SDK 빌드</li>
<li>Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델</li>
</ul>
<p>이 문서에서는 첫번째 과정인 필요한 layer를 추가해서 빌드하여 타겟에 올려서 동작을 확인하는 과정을 설명한다.</p>]]></description></item><item><title>Orange Pi 보드용 이미지 수작업으로 만들기</title><link>https://blog.humminglab.io/posts/orange-pi-based-factory-image/</link><pubDate>Wed, 30 May 2018 10:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/orange-pi-based-factory-image/</guid><description><![CDATA[<p><a href="http://www.orangepi.org" target="_blank" rel="noopener noreferrer">Orange Pi</a> 는 Allwinner(<a href="http://linux-sunxi.org/Main_Page" target="_blank" rel="noopener noreferrer">SUNXI</a>) 의 application chip으로 만들어진 single board computer이다. Raspberry Pi 와 비슷하다고 볼 수 있는데, 이것과 비교하여 주요 장단점은 다음과 같다.</p>
<ul>
<li>장점
<ul>
<li>Cortex A8 single core부터 octa core 까지 라인업</li>
<li>Mali400 GPU 내장</li>
<li>무엇보다도 가격이 저렴. 아래에서 사용하는 <a href="http://www.orangepi.org/OrangePiR1/" target="_blank" rel="noopener noreferrer">Orange Pi R1</a>의 경우 <a href="https://www.aliexpress.com/store/product/Orange-Pi-One-ubuntu-linux-and-android-mini-PC-Beyond-and-Compatible-with-Raspberry-Pi-2/1553371_32603308880.html" target="_blank" rel="noopener noreferrer">소비자가가 $9.99</a>.</li>
</ul>
</li>
<li>단점
<ul>
<li>CPU 사양이 제대로 공개가 안됨. 그나마 H3 정도까지는 인터넷 커뮤니티에 어느정도 공개 됨</li>
<li>발열이 심함. Orange Pi R1의 경우도 별도로 방열판을 붙어야 안정적임</li>
</ul>
</li>
</ul>
<p>이 문서에서는 Orange Pi R1을 제품에 적용하기 위하여 보드 이미지 설정을 하는 과정을 정리한 것이다.</p>]]></description></item><item><title>WICED eventloop library</title><link>https://blog.humminglab.io/posts/wiced-event-loop/</link><pubDate>Tue, 17 Apr 2018 17:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/wiced-event-loop/</guid><description><![CDATA[<p><a href="http://www.cypress.com/products/wiced-software" target="_blank" rel="noopener noreferrer">WICED</a>와 같은 임베디드 디바이스용 SDK는 <a href="https://freertos.org" target="_blank" rel="noopener noreferrer">FreeRTOS</a>, <a href="https://rtos.com/solutions/threadx/real-time-operating-system/" target="_blank" rel="noopener noreferrer">ThreadX</a>와 같은 RTOS의 multi tasking 기능을 이용하여 여러개의 task를 생성하여 주변기기를 제어하거나 네트워크로 데이타 송수신 한다. 일반적인 산업용 기기의 센서 동작은 realtime 요구 사항에 맞추어 task로 분리하여 작성하면 된다. 하지만 가정용 IoT 기기를 만들다 보면 이와 같은 multi task 방식 보다는 하나의 task에서 event driven 방식으로 구현을 하는 것이 편리할 때가 있다.</p>
<p>이 문서에서는 가정용 기기의 특징과 이를 task 방식으로 구현하였을 때의 단점을 설명하고, 구현한 event loop library를 설명한다.</p>]]></description></item></channel></rss>