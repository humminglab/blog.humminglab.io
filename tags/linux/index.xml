<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Linux - Tag - All about IoT</title><link>https://blog.humminglab.io/tags/linux/</link><description>Linux - Tag - All about IoT</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>info@humminglab.io (HummingLab)</managingEditor><webMaster>info@humminglab.io (HummingLab)</webMaster><lastBuildDate>Tue, 07 Jun 2022 09:00:00 +0900</lastBuildDate><atom:link href="https://blog.humminglab.io/tags/linux/" rel="self" type="application/rss+xml"/><item><title>Systemd의 특징과 Yocto에 적용하기</title><link>https://blog.humminglab.io/posts/yocto-systemd/</link><pubDate>Tue, 07 Jun 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-systemd/</guid><description><![CDATA[<p>Yocto project에서 기본 설정으로 빌드하면 SysV Init를 사용한다.
개발하는 제품이 이더넷 네트워크로 연결되고, 부팅 이후에는 네트워크 환경이 변하지 않는다면 SysV Init를 이용하는 것이 구조도 단순해서 더 좋을 수 있다.</p>
<p>하지만 다음과 같은 사항을 고려하고 있다면 systemd를 적용하는 것을 검토해 볼 수 있다.</p>
<ul>
<li>Daemon 이 죽는 경우를 검출하여 재시작 관리가 필요한 경우</li>
<li>Wi-Fi 와 같이 동적으로 변경될 수 있는 네트워크 관리가 필요한 경우</li>
<li>불규칙하게 네트워크가 끊길 수 있는 조건에서 시간 동기화가 필요한 경우</li>
<li>프로그램에 CPU 또는 메모리 자원을 제한하기 위하여 <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt" target="_blank" rel="noopener noreferrer">cgroups</a>를 사용하려는 경우</li>
<li>효과적인 로그 관리를 위하여 journald를 사용하고 싶은 경우</li>
<li>부팅 직후 초기 프로세스의 실행 시간을 줄여 보려는 경우</li>
</ul>
<p>물론 위의 기능을 사용하기 위해서 systemd만 가능한 것은 아니지만, systemd를 사용하는 경우 별도의 프로그램 없이 위 기능을 쉽게 적용할 수 있다.</p>]]></description></item><item><title>Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/</link><pubDate>Tue, 18 Jan 2022 23:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/</guid><description><![CDATA[<p>Yocto Project 개발 절차는 기본적으로 이미 개발이 완료된 패키지들의 recipe를 만들고, 이를 bitbake로 전체 이미지를 빌드하는 과정이다.</p>
<p>하지만 개발 진행 중인 소프트웨어 패키지를 yocto에 추가하고, 이를 계속 수정 개발을 할 때 어떤 방식으로 관리를 할지 고민을 하여야 한다.
여기에서는 이와 같이 개발 중인 패키지를 yocto 에 추가하여 빌드 하는 방법을 알아본다.</p>
<ul>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/" rel="">Yocto Project 개발하기(1) - Orange Pi 보드 빌드</a></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/" rel="">Yocto Project 개발하기(2) - Custom Layer 만들기</a></li>
<li><strong>Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</strong></li>
<li>Yocto Project 개발하기(4) - Yocto SDK 빌드</li>
<li>Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델</li>
</ul>
<h2 id="방법들" class="headerLink">
    <a href="#%eb%b0%a9%eb%b2%95%eb%93%a4" class="header-mark"></a>방법들</h2><p>예를 들어 u-boot 를 수정 하는 경우를 예로 들어 보자.
수정되어 commit 된 경우라면 bb(append) recipe만 수정해서 재실행하면 되지만, commit 전에 yocto 에 추가하여 빌드하려면 다음과 같은 방법을 고려해 볼 수 있다.</p>]]></description></item><item><title>Yocto Project 개발하기(2) - Custom Layer 만들기</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</link><pubDate>Fri, 07 Jan 2022 19:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</guid><description><![CDATA[<p><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/" rel="">이전 글</a> 에서 meta-sunxi 를 추가하여 orage pi 용으로 빌드를 만들었고, 이번 과정은 project 용으로 meta layer를 만들어서 관리하는 방법을 설명한다.</p>
<p>실제 개발 과정을 이해하기 좋도록 meta layer 를 만들어 가는 과정을 설명한다.</p>
<ul>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/" rel="">Yocto Project 개발하기(1) - Orange Pi 보드 빌드</a></li>
<li><strong>Yocto Project 개발하기(2) - Custom Layer 만들기</strong></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/" rel="">Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</a></li>
<li>Yocto Project 개발하기(4) - Yocto SDK 빌드</li>
<li>Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델</li>
</ul>
<h2 id="layer-및-machine-생성" class="headerLink">
    <a href="#layer-%eb%b0%8f-machine-%ec%83%9d%ec%84%b1" class="header-mark"></a>Layer 및 machine 생성</h2><p>프로젝트를 sc-gateway 라고 명하고(이름에 특별한 의미는 없음), 이를 layer로 만든다. 다음과 같이 yocto 폴더 안에 meta-sc-gateway를 생성한다.</p>]]></description></item><item><title>Yocto Project 개발하기(1) - Orange Pi 보드 빌드</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/</link><pubDate>Thu, 30 Dec 2021 22:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/</guid><description><![CDATA[<p>이 문서는 <a href="http://www.orangepi.org/orangepizero/" target="_blank" rel="noopener noreferrer">Orange Pi Zero</a> 보드에서 <a href="https://www.yoctoproject.org/" target="_blank" rel="noopener noreferrer">Yocto Project</a>를 이용하여 배포본을 만들고, 개별 패키지를 관리하는 방법에 대하여 설명한다.</p>
<p>설명은 다음과 같이 나누어서 설명을 할 예정이다.</p>
<ul>
<li><strong>Yocto Project 개발하기(1) - Orange Pi 보드 빌드</strong></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/" rel="">Yocto Project 개발하기(2) - Custom Layer 만들기</a></li>
<li><a href="https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/" rel="">Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</a></li>
<li>Yocto Project 개발하기(4) - Yocto SDK 빌드</li>
<li>Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델</li>
</ul>
<p>이 문서에서는 첫번째 과정인 필요한 layer를 추가해서 빌드하여 타겟에 올려서 동작을 확인하는 과정을 설명한다.</p>]]></description></item><item><title>SD card 디스크 이미지 만들고 수정하는 방법 정리</title><link>https://blog.humminglab.io/posts/how-to-make-sdcard-disk-image/</link><pubDate>Wed, 25 Oct 2017 18:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/how-to-make-sdcard-disk-image/</guid><description><![CDATA[<p><a href="https://www.yoctoproject.org" target="_blank" rel="noopener noreferrer">Yocto Project</a>나 <a href="https://buildroot.org" target="_blank" rel="noopener noreferrer">Buildroot</a>를 이용하여 embedded linux 시스템을 빌드하면 SD card나 MMC에 쓸수 있는 이미지까지 생성해 준다. 하지만 빌드되는 디스크 이미지 형태와 다르게 파티셔닝을 하려면 관련된 정보들을 알고 있어야 한다.</p>
<p>여기에서는 <a href="https://linux.die.net/man/1/dd" target="_blank" rel="noopener noreferrer">dd</a>, <a href="https://linux.die.net/man/1/truncate" target="_blank" rel="noopener noreferrer">truncate</a>, <a href="https://linux.die.net/man/8/fdisk" target="_blank" rel="noopener noreferrer">fdisk</a>, <a href="https://www.gnu.org/software/parted/" target="_blank" rel="noopener noreferrer">parted</a>, <a href="https://linux.die.net/man/8/mount" target="_blank" rel="noopener noreferrer">mount</a>, <a href="https://linux.die.net/man/8/losetup" target="_blank" rel="noopener noreferrer">losetup</a> 등의 utility를 이용하여 디스크 이미지를 생성, 수정, 관리하는 방법을 정리한다.</p>
<h2 id="물리적인-저장-디스크-관리" class="headerLink">
    <a href="#%eb%ac%bc%eb%a6%ac%ec%a0%81%ec%9d%b8-%ec%a0%80%ec%9e%a5-%eb%94%94%ec%8a%a4%ed%81%ac-%ea%b4%80%eb%a6%ac" class="header-mark"></a>물리적인 저장 디스크 관리</h2><p>Linux의 경우 저장 디스크는 block device로 /dev 디렉토리에 아래와 같은 디바이스 파일이 생성된다. 아래의 예는 sda SSD 디스크로 한 개의 파티션(sda1)이 있다.</p>]]></description></item></channel></rss>